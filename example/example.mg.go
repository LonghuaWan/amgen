// Code generated by mgen.
// source:
// example.yml
// DO NOT EDIT

package example

import (
	"log"
	"time"

	mgo "gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
)

//go:generate goimports -w ./example.mg.go
var (
	db *DB
)

type DB struct {
	name    string
	session *mgo.Session
}

func NewDB(name string) *DB {
	if db == nil {
		db = &DB{
			name: name,
		}
	}

	return db
}

func (db *DB) InitDB(session *mgo.Session) {
	if session == nil {
		log.Fatalf("[FATAL] you must connect database\n")
	}
	db.session = session

	log.Printf("[INFO] %v connection succeeded\n", db.name)
}

func GetSessionAndCollection(collection string) (*mgo.Session, *mgo.Collection) {
	s := db.session.Copy()
	c := s.DB(db.name).C(collection)

	return s, c
}

func GetSessionAndGridFS(prefix string) (*mgo.Session, *mgo.GridFS) {
	s := db.session.Copy()
	f := s.DB(db.name).GridFS(prefix)
	return s, f
}

type Address struct {
	Nation      string `bson:"nation,omitempty" json:"nation"`
	Province    string `bson:"province,omitempty" json:"province"`
	City        string `bson:"city,omitempty" json:"city"`
	District    string `bson:"district,omitempty" json:"district"`
	Address     string `bson:"address,omitempty" json:"address"`
	Zip         string `bson:"zip,omitempty" json:"zip"`
	Phone       string `bson:"phone,omitempty" json:"phone"`
	Fax         string `bson:"fax,omitempty" json:"fax"`
	MobilePhone string `bson:"mobile_phone,omitempty" json:"mobile_phone"`
}

const (
	CollectionUser = "users"
)

type User struct {
	ID        bson.ObjectId `bson:"_id,omitempty" json:"_id"`
	UserName  string        `bson:"user_name,omitempty" json:"user_name" valid:"required"`
	Email     string        `bson:"email,omitempty" json:"email" valid:"required"`
	Password  string        `bson:"password,omitempty" json:"password" valid:"required"`
	CreatedAt time.Time     `bson:"created_at,omitempty" json:"created_at"`
	UpdatedAt time.Time     `bson:"updated_at,omitempty" json:"updated_at"`
}

func NewUser() *User {
	return &User{}
}

func (user *User) Insert() error {
	s, c := GetSessionAndCollection(CollectionUser)
	defer s.Close()

	if err := c.EnsureIndex(mgo.Index{
		Key:        []string{"user_name"},
		Unique:     true,
		DropDups:   false,
		Background: true,
	}); err != nil {
		return err
	}
	if err := c.EnsureIndex(mgo.Index{
		Key:        []string{"email"},
		Unique:     true,
		DropDups:   false,
		Background: true,
	}); err != nil {
		return err
	}
	if err := c.EnsureIndex(mgo.Index{
		Key:        []string{"password"},
		Unique:     true,
		DropDups:   false,
		Background: true,
	}); err != nil {
		return err
	}

	user.ID = bson.NewObjectId()
	user.CreatedAt = time.Now().UTC()

	return c.Insert(user)
}

func UpdateUserByID(id string, user *User) error {
	s, c := GetSessionAndCollection(CollectionUser)
	defer s.Close()

	user.UpdatedAt = time.Now().UTC()

	return c.UpdateId(bson.ObjectIdHex(id), bson.M{
		"$set": user,
	})
}

func UpdateUserBySelector(selector interface{}, user *User) error {
	s, c := GetSessionAndCollection(CollectionUser)
	defer s.Close()

	user.UpdatedAt = time.Now().UTC()

	return c.Update(selector, bson.M{
		"$set": user,
	})
}

func FindUserByID(id string) (*User, error) {
	s, c := GetSessionAndCollection(CollectionUser)
	defer s.Close()

	user := new(User)

	if bson.IsObjectIdHex(id) {
		return user, c.FindId(id).One(user)
	}

	return user, c.FindId(bson.ObjectIdHex(id)).One(user)
}

func FindUserByQuery(query interface{}) (*User, error) {
	s, c := GetSessionAndCollection(CollectionUser)
	defer s.Close()

	user := new(User)

	return user, c.Find(query).One(user)
}

func FindAllUserByQuery(query interface{}) ([]*User, error) {
	s, c := GetSessionAndCollection(CollectionUser)
	defer s.Close()

	user := make([]*User, 0)

	return user, c.Find(query).All(&user)
}

func ExistUserByID(id string) (bool, error) {
	s, c := GetSessionAndCollection(CollectionUser)
	defer s.Close()

	user := new(User)

	if err := c.FindId(bson.ObjectIdHex(id)).One(user); err != nil {
		if err == mgo.ErrNotFound {
			return false, nil
		}
		return false, err
	}

	return true, nil
}

func ExistUserByQuery(query interface{}) (bool, error) {
	s, c := GetSessionAndCollection(CollectionUser)
	defer s.Close()

	user := new(User)

	if err := c.Find(query).One(user); err != nil {
		if err == mgo.ErrNotFound {
			return false, nil
		}
		return false, err
	}

	return true, nil
}

func DeleteUserByID(id string) error {
	s, c := GetSessionAndCollection(CollectionUser)
	defer s.Close()

	return c.RemoveId(bson.ObjectIdHex(id))
}
