// Code generated by cmgen.
// source:
// advanced.yaml

package base

import (
    "errors"
    "github.com/globalsign/mgo"
    "github.com/globalsign/mgo/bson"
    "github.com/liamylian/jsontime"
    "time"
)

var (
    ErrorInvalidObjectId = errors.New("invalid objectId")
    json = jsontime.ConfigWithCustomTimeFormat
)

      
const (
    DbNameUser = "test"
    CollectionUser = "users"
)
    

func GetUserSessionAndCollection() (*mgo.Session, *mgo.Collection) {
    //FIXME init MongoSession
	s := MongoSession.Copy()
	c := s.DB(DbNameUser).C(CollectionUser)

	return s, c
}

type User struct {
    ID bson.ObjectId `bson:"_id" json:"id"`
    UserName string `bson:"user_name" json:"user_name,omitempty" valid:"required~first name is blank"`
    Email string `bson:"email" json:"email,omitempty" valid:"required,email"`
    Password string `bson:"password" json:"password,omitempty" valid:"required"`
    Ct int64 `bson:"ct" json:"ct"`
    Mt int64 `bson:"mt" json:"mt"`
    Deleted int `bson:"deleted" json:"-"`
}

func NewUser() *User{
    return &User{}
}

func (user *User) Insert() error {
    s, c := GetUserSessionAndCollection()
    defer s.Close()
    
    if err := c.EnsureIndex(mgo.Index{
        Key: []string{"user_name"},
        Unique:     true,
        DropDups:   false,
        Background: true,
    }); err != nil {
        return err
    }
    if err := c.EnsureIndex(mgo.Index{
        Key: []string{"email"},
        Unique:     true,
        DropDups:   false,
        Background: true,
    }); err != nil {
        return err
    }

    user.ID = bson.NewObjectId()
    user.Ct = time.Now().UnixNano()
    user.Mt = time.Now().UnixNano()
    user.Deleted = 0

    return c.Insert(user)
}

func UpdateUserByID(id bson.ObjectId, user *User) error {
    s, c := GetUserSessionAndCollection()
    defer s.Close()

    user.Mt = time.Now().UnixNano()

    return c.UpdateId(id, bson.M{
        "$set": user,
    })
}

func UpdateUserByIDAndEntityMap(id bson.ObjectId, updateMap map[string]interface{}) error {
    s, c := GetUserSessionAndCollection()
    defer s.Close()

    if updateMap == nil { return nil }
    updateMap ["mt"] = time.Now().UnixNano()

    return c.UpdateId(id, bson.M{
        "$set": updateMap,
    })
}

// Update finds a single document matching the provided selector document
// and modifies it according to the update document.
// If the session is in safe mode (see SetSafe) a ErrNotFound error is
// returned if a document isn't found, or a value of type *LastError
// when some other error is detected.
//
// Relevant documentation:
//
//     http://www.mongodb.org/display/DOCS/Updating
//     http://www.mongodb.org/display/DOCS/Atomic+Operations
//
func UpdateUser(selector interface{}, user *User) error {
    s, c := GetUserSessionAndCollection()
    defer s.Close()

    user.Mt = time.Now().UnixNano()

    return c.Update(selector, bson.M{
        "$set": user,
    })
}

// UpdateAll finds all documents matching the provided selector document
// and modifies them according to the update document.
// If the session is in safe mode (see SetSafe) details of the executed
// operation are returned in info or an error of type *LastError when
// some problem is detected. It is not an error for the update to not be
// applied on any documents because the selector doesn't match.
//
// Relevant documentation:
//
//     http://www.mongodb.org/display/DOCS/Updating
//     http://www.mongodb.org/display/DOCS/Atomic+Operations
//
func UpdateUserAll(selector interface{}, user *User) (*mgo.ChangeInfo, error) {
    s, c := GetUserSessionAndCollection()
    defer s.Close()

    user.Mt = time.Now().UnixNano()

    return c.UpdateAll(selector, bson.M{
        "$set": user,
    })
}

func GetUserByID(id bson.ObjectId) (*User, error) {
    s, c := GetUserSessionAndCollection()
    defer s.Close()

    user := new(User)
    err := c.FindId(id).One(user)
    if err == mgo.ErrNotFound {
        return nil, nil
    }
    return user, nil
}

func GetOneUserByQuery(query map[string]interface{}) (*User, error) {
    s, c := GetUserSessionAndCollection()
    defer s.Close()

    if query == nil { query = map[string]interface{}{} }
    query["deleted"] = 0

    user := new(User)

    err := c.Find(query).One(user)
    if err == mgo.ErrNotFound {
        return nil, nil
    }
    return user, nil
}

func ListAllUserByQuery(query map[string]interface{}) ([]*User, error) {
    s, c := GetUserSessionAndCollection()
    defer s.Close()

    if query == nil { query = map[string]interface{}{} }
    query["deleted"] = 0

    user := make([]*User, 0)

    return user, c.Find(query).All(&user)
}

func ListAllUserByQueryWithOffsetAndLimit(query map[string]interface{}, offset, limit int) ([]*User, error) {
    s, c := GetUserSessionAndCollection()
    defer s.Close()

    if query == nil { query = map[string]interface{}{} }
    query["deleted"] = 0

    user := make([]*User, 0)

    return user, c.Find(query).Skip(offset).Limit(limit).All(&user)
}

func ListAllUserByQueryWithOrder(query map[string]interface{}, offset, limit int, order... string) ([]*User, error) {
    s, c := GetUserSessionAndCollection()
    defer s.Close()

    if query == nil { query = map[string]interface{}{} }
    query["deleted"] = 0

    user := make([]*User, 0)
    tmp := c.Find(query)
    if len(order) > 0 {
        tmp = tmp.Sort(order...)
    }
    return user, tmp.Skip(offset).Limit(limit).All(&user)
}

func ExistUserByID(id bson.ObjectId) (bool, error) {
    s, c := GetUserSessionAndCollection()
    defer s.Close()

    user := new(User)

    if err := c.FindId(id).One(user); err != nil {
        if err == mgo.ErrNotFound {
            return false, nil
        }
        return false, err
    }

    return true, nil
}

func DeleteUserByID(id bson.ObjectId) error {
    s, c := GetUserSessionAndCollection()
    defer s.Close()

    return c.UpdateId(id, bson.M{
        "$set": bson.M{"deleted": 1},
    })
}



