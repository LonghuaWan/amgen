// Code generated by amgen.
// source:
// {{.ConfigName}}
// DO NOT EDIT

package {{.PackageName}}

import (
    "context"
	"gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
    "time"
)

  {{range $_, $Model := .Models}}  {{$name := $Model.Name|ToLower}}{{$Name := $Model.Name}}  {{if .CollectionName}}
const (
    Collection{{$Model.Name}} = "{{$Model.CollectionName|SnakeString}}"
)

  {{if $Model.Types}}
const ({{range $Model.Types}}
    {{$Name}}Type{{.}} = "{{.}}"  {{end}}
)

var (
    {{$Name}}TypesMap = map[string]string{  {{range $Model.Types}}
        {{$Name}}Type{{.}}: "{{.}}",  {{end}}
    }
)

func Check{{$Name}}Type(typename string) bool {
    return {{$Name}}TypesMap[typename] != ""
}
{{end}}  {{if $Model.States}}
const ({{range $Model.States}}
    {{$Name}}State{{.}} = "{{.}}"  {{end}}
)

var (
    {{$Name}}StatesMap = map[string]string{  {{range $Model.States}}
        {{$Name}}State{{.}}: "{{.}}",  {{end}}
    }
)

func Check{{$Name}}States(status string) bool {
    return {{$Name}}StatesMap[status] != ""
}  {{end}}

func (d *dao) Get{{$Name}}SessionAndCollection(collectionName string) (*mgo.Session, *mgo.Collection) {
	s := d.mongo.Clone()
	c := s.DB(MongodbDBName).C(collectionName)
	return s, c
}

type {{$Name}} struct {
    ID bson.ObjectId `bson:"_id" json:"id"`{{range $Model.Fields}}{{if not .Anonymous}}
    {{.Name}} {{.Type}} `bson:"{{.Name|SnakeString}}" json:"{{.Name|SnakeString}},omitempty"{{if .Valid}} valid:"{{.Valid}}"{{end}}` {{ else }}
    {{.Type}} {{end}}{{end}}
    Ct int64 `bson:"ct" json:"ct"`
    Mt int64 `bson:"mt" json:"mt"`
    Deleted int `bson:"deleted" json:"-"`
    CollectionName string `bson:"-" json:"-"` //指定表名
}

func New{{$Name}}() *{{$Name}}{
    return &{{$Name}}{CollectionName: Collection{{$Model.Name}}}
}

func (t *{{$Name}}) GetCollectionName() string {
    return t.CollectionName
}

{{if $Model.Indexes}}
func (d *dao) Init{{$Name}}Index(collectionName string) error {
    s, c := d.Get{{$Name}}SessionAndCollection(collectionName)
    defer s.Close()
    {{range $Model.Indexes}}{{if .Unique }}
    if err := c.EnsureIndex(mgo.Index{
        Key: func() []string{
            keys := []string{}
            {{range .Name}}
            keys = append(keys, "{{.|SnakeString}}"){{end}}
            return keys
        }(),
        Unique:     true,
        DropDups:   false,
        Background: true,
    }); err != nil {
        return err
    }{{ else }}
    if err := c.EnsureIndex(mgo.Index{
        Key: func() []string{
                keys := []string{}
                {{range .Name}}
                keys = append(keys, "{{.|SnakeString}}"){{end}}
                return keys
            }(),
        Unique:     false,
        DropDups:   false,
        Background: true,
    }); err != nil {
        return err
    }{{end}}{{end}}

    if err := c.EnsureIndex(mgo.Index{
        Key: []string{"Ct"},
        Unique:     false,
        DropDups:   false,
        Background: true,
    }); err != nil {
        return err
    }

    return nil
}
{{end}}

func (d *dao) Insert{{$Name}}(ctx context.Context, {{$name}} *{{$Name}}) error {
    s, c := d.Get{{$Name}}SessionAndCollection({{$name}}.GetCollectionName())
    defer s.Close()

    {{$name}}.ID = bson.NewObjectId()
    {{$name}}.Ct = time.Now().UnixNano()
    {{$name}}.Mt = time.Now().UnixNano()
    {{$name}}.Deleted = 0

    return c.Insert({{$name}})
}

func (d *dao) Update{{$Name}}ByID(ctx context.Context, id bson.ObjectId, {{$name}} *{{$Name}}) error {
    s, c := d.Get{{$Name}}SessionAndCollection({{$name}}.GetCollectionName())
    defer s.Close()

    {{$name}}.Mt = time.Now().UnixNano()

    return c.UpdateId(id, bson.M{
        "$set": {{$name}},
    })
}

func (d *dao) Update{{$Name}}ByIDAndEntityMap(ctx context.Context, collectionName string, id bson.ObjectId, updateMap map[string]interface{}) error {
    s, c := d.Get{{$Name}}SessionAndCollection(collectionName)
    defer s.Close()

    if updateMap == nil { return nil }
    updateMap ["mt"] = time.Now().UnixNano()

    return c.UpdateId(id, bson.M{
        "$set": updateMap,
    })
}

// Update finds a single document matching the provided selector document
// and modifies it according to the update document.
// If the session is in safe mode (see SetSafe) a ErrNotFound error is
// returned if a document isn't found, or a value of type *LastError
// when some other error is detected.
//
// Relevant documentation:
//
//     http://www.mongodb.org/display/DOCS/Updating
//     http://www.mongodb.org/display/DOCS/Atomic+Operations
//
func (d *dao) Update{{$Name}}(ctx context.Context, selector interface{}, {{$name}} *{{$Name}}) error {
    s, c := d.Get{{$Name}}SessionAndCollection({{$name}}.GetCollectionName())
    defer s.Close()

    {{$name}}.Mt = time.Now().UnixNano()

    return c.Update(selector, bson.M{
        "$set": {{$name}},
    })
}

// UpdateAll finds all documents matching the provided selector document
// and modifies them according to the update document.
// If the session is in safe mode (see SetSafe) details of the executed
// operation are returned in info or an error of type *LastError when
// some problem is detected. It is not an error for the update to not be
// applied on any documents because the selector doesn't match.
//
// Relevant documentation:
//
//     http://www.mongodb.org/display/DOCS/Updating
//     http://www.mongodb.org/display/DOCS/Atomic+Operations
//
func (d *dao) Update{{$Name}}All(selector interface{}, {{$name}} *{{$Name}}) (*mgo.ChangeInfo, error) {
    s, c := d.Get{{$Name}}SessionAndCollection({{$name}}.GetCollectionName())
    defer s.Close()

    {{$name}}.Mt = time.Now().UnixNano()

    return c.UpdateAll(selector, bson.M{
        "$set": {{$name}},
    })
}

func (d *dao) Update{{$Name}}ByEntityMap(ctx context.Context, collectionName string, selector interface{}, updateMap map[string]interface{}) error {
    s, c := d.Get{{$Name}}SessionAndCollection(collectionName)
    defer s.Close()

    if updateMap == nil { return nil }
    updateMap ["mt"] = time.Now().UnixNano()

    return c.Update(selector, bson.M{
        "$set": updateMap,
    })
}

func (d *dao) Get{{$Name}}ByID(ctx context.Context, collectionName string, id bson.ObjectId) (*{{$Name}}, error) {
    s, c := d.Get{{$Name}}SessionAndCollection(collectionName)
    defer s.Close()

    {{$name}} := new({{$Name}})
    err := c.FindId(id).One({{$name}})
    if err == mgo.ErrNotFound {
        return nil, nil
    }
    return {{$name}}, nil
}

func (d *dao) Get{{$Name}}ByIDWithSelect(ctx context.Context, collectionName string, selector interface{}, id bson.ObjectId) (*{{$Name}}, error) {
    s, c := d.Get{{$Name}}SessionAndCollection(collectionName)
    defer s.Close()

    {{$name}} := new({{$Name}})
    err := c.FindId(id).Select(selector).One({{$name}})
    if err == mgo.ErrNotFound {
        return nil, nil
    }
    return {{$name}}, nil
}

func (d *dao) GetOne{{$Name}}ByQuery(ctx context.Context, collectionName string, query map[string]interface{}) (*{{$Name}}, error) {
    s, c := d.Get{{$Name}}SessionAndCollection(collectionName)
    defer s.Close()

    if query == nil { query = map[string]interface{}{} }
    query["deleted"] = 0

    {{$name}} := new({{$Name}})

    err := c.Find(query).One({{$name}})
    if err == mgo.ErrNotFound {
        return nil, nil
    }
    return {{$name}}, nil
}

func (d *dao) GetOne{{$Name}}ByQueryWithSelect(ctx context.Context, collectionName string, selector interface{}, query map[string]interface{}) (*{{$Name}}, error) {
    s, c := d.Get{{$Name}}SessionAndCollection(collectionName)
    defer s.Close()

    if query == nil { query = map[string]interface{}{} }
    query["deleted"] = 0

    {{$name}} := new({{$Name}})

    err := c.Find(query).Select(selector).One({{$name}})
    if err == mgo.ErrNotFound {
        return nil, nil
    }
    return {{$name}}, nil
}

func (d *dao) ListAll{{$Name}}ByQuery(ctx context.Context, collectionName string, query map[string]interface{}) ([]*{{$Name}}, error) {
    s, c := d.Get{{$Name}}SessionAndCollection(collectionName)
    defer s.Close()

    if query == nil { query = map[string]interface{}{} }
    query["deleted"] = 0

    {{$name}} := make([]*{{$Name}}, 0)

    return {{$name}}, c.Find(query).All(&{{$name}})
}

func (d *dao) ListAll{{$Name}}ByQueryWithSelect(ctx context.Context, collectionName string, selector interface{}, query map[string]interface{}) ([]*{{$Name}}, error) {
    s, c := d.Get{{$Name}}SessionAndCollection(collectionName)
    defer s.Close()

    if query == nil { query = map[string]interface{}{} }
    query["deleted"] = 0

    {{$name}} := make([]*{{$Name}}, 0)

    return {{$name}}, c.Find(query).Select(selector).All(&{{$name}})
}

func (d *dao) ListAll{{$Name}}ByQueryWithOffsetAndLimit(ctx context.Context, collectionName string, query map[string]interface{}, offset, limit int) ([]*{{$Name}}, error) {
    s, c := d.Get{{$Name}}SessionAndCollection(collectionName)
    defer s.Close()

    if query == nil { query = map[string]interface{}{} }
    query["deleted"] = 0

    {{$name}} := make([]*{{$Name}}, 0)

    return {{$name}}, c.Find(query).Skip(offset).Limit(limit).All(&{{$name}})
}

func (d *dao) ListAll{{$Name}}ByQueryWithOffsetAndLimitAndSelect(ctx context.Context, collectionName string, query map[string]interface{}, offset, limit int, selector interface{}) ([]*{{$Name}}, error) {
    s, c := d.Get{{$Name}}SessionAndCollection(collectionName)
    defer s.Close()

    if query == nil { query = map[string]interface{}{} }
    query["deleted"] = 0

    {{$name}} := make([]*{{$Name}}, 0)

    return {{$name}}, c.Find(query).Select(selector).Skip(offset).Limit(limit).All(&{{$name}})
}

func (d *dao) ListAll{{$Name}}ByQueryWithOrder(ctx context.Context, collectionName string, query map[string]interface{}, offset, limit int, order... string) ([]*{{$Name}}, error) {
    s, c := d.Get{{$Name}}SessionAndCollection(collectionName)
    defer s.Close()

    if query == nil { query = map[string]interface{}{} }
    query["deleted"] = 0

    {{$name}} := make([]*{{$Name}}, 0)
    tmp := c.Find(query)
    if len(order) > 0 {
        tmp = tmp.Sort(order...)
    }
    return {{$name}}, tmp.Skip(offset).Limit(limit).All(&{{$name}})
}

func (d *dao) ListAll{{$Name}}ByQueryWithOrderAndSelect(ctx context.Context, collectionName string, query map[string]interface{}, offset, limit int, selector interface{}, order... string) ([]*{{$Name}}, error) {
    s, c := d.Get{{$Name}}SessionAndCollection(collectionName)
    defer s.Close()

    if query == nil { query = map[string]interface{}{} }
    query["deleted"] = 0

    {{$name}} := make([]*{{$Name}}, 0)
    tmp := c.Find(query)
    if len(order) > 0 {
        tmp = tmp.Sort(order...)
    }
    return {{$name}}, tmp.Select(selector).Skip(offset).Limit(limit).All(&{{$name}})
}


func (d *dao) Exist{{$Name}}ByID(ctx context.Context, collectionName string, id bson.ObjectId) (bool, error) {
    s, c := d.Get{{$Name}}SessionAndCollection(collectionName)
    defer s.Close()

    {{$name}} := new({{$Name}})

    if err := c.FindId(id).Select(bson.M{"_id":1}).One({{$name}}); err != nil {
        if err == mgo.ErrNotFound {
            return false, nil
        }
        return false, err
    }

    return true, nil
}

func (d *dao) Exist{{$Name}}ByQuery(ctx context.Context, collectionName string, query map[string]interface{}) (bool, error) {
    s, c := d.Get{{$Name}}SessionAndCollection(collectionName)
    defer s.Close()

    {{$name}} := new({{$Name}})

    if err := c.Find(query).Select(bson.M{"_id":1}).One({{$name}}); err != nil {
        if err == mgo.ErrNotFound {
            return false, nil
        }
        return false, err
    }

    return true, nil
}

func (d *dao) Delete{{$Name}}ByID(ctx context.Context, collectionName string, id bson.ObjectId) error {
    s, c := d.Get{{$Name}}SessionAndCollection(collectionName)
    defer s.Close()

    return c.UpdateId(id, bson.M{
        "$set": bson.M{"deleted": 1},
    })
}

func (d *dao) Inc{{$Name}}ByEntityMap(ctx context.Context, collectionName string, selector interface{}, incMap map[string]interface{}) error {
    s, c := d.Get{{$Name}}SessionAndCollection(collectionName)
    defer s.Close()

    updateMap := map[string]interface{}{}
    updateMap ["mt"] = time.Now().UnixNano()

    return c.Update(selector, bson.M{
        "$inc": incMap,
        "$set": updateMap,
    })
}

{{else}}
type {{$Name}} struct { {{range $Model.Fields}}{{if not .Anonymous}}
    {{.Name}} {{.Type}} `bson:"{{.Name|SnakeString}}" json:"{{.Name|SnakeString}},omitempty"{{if .Valid}} valid:"{{.Valid}}"{{end}}` {{ else }}
    {{.Type}} {{end}}{{end}}
}
{{end}}{{end}}

{{.Raw}}